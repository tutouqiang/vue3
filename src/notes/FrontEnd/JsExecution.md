# JS 执行

涉及以下几个知识点

上下文：创建 ——> 执行 ——> 销毁

Event Loop：执行栈 ——> 任务队列 （微任务（microtask）、宏任务（macrotask））

涉及： 同步、异步

编译 -> 执行

## 编译

### 词法分析（Lexical Analyser）

将没一行的代码按照词义单位拆解，直到不能再拆成更小的字符，然后进行评估（evaluating），判断词义单位属于哪一类的值。如

```js
var a = 123;
// 词法分析后的结果
[
  "var" : "keyword",
  "a" : "identifier",
  "="   : "assignment",
  "123"  : "integer",
  ";"   : "eos" (end of statement)
]

```

### 语法分析（Syntax Parser）

根据语法规则，转为抽象语法树（Abstract Syntax Tree，简称 AST）。如果源码符合语法规则，这一步就会顺利完成，生成一个抽象语法树；如果源码存在语法错误，这一步就会终止，抛出一个“语法错误”。

```js
{
  operation: "=",
  left: {
    keyword: "var",
    right: "sum"
  }
  right: "30"
}
```

上面代码中，抽象语法树的一个节点是赋值操作符（=），它两侧的词义单位，分别成左侧子节点和右侧子节点。这一步是整个 JavaScript 代码执行过程中最慢的。

## 执行

### 执行上下文（Execution Context）

一种抽象的概念，js 是一种解释性语言即 runtime，执行上下文可以看做是对 js 代码进行解释、执行、回收。主要由以下三个步骤组成：

#### 一、创建上下文（解释阶段）

主要作用：变量提升、明确作用域、作用域链、this 的指向（此时期，不做变量的赋值，提升的变量都为 undefind）

1、全局上下文：一个程序中只能有一个全局上下文，并将 this 指向全局

2、函数上下文：函数被调用时创建。每个函数都有自己的上下文，函数执行上下文中会多出 this arguments 和函数的参数。

3、eval 函数上下文（mdn 不建议使用的函数、有一定的危险性，这里不讨论）

### 二、执行上下文（执行阶段）

执行变量赋值、代码执行；可视化：https://www.jsv9000.app/

执行代码的步骤，也就是 Event Loop 的整个过程，涉及主线程、执行栈（看做水桶，先进后出）、任务队列（看做排队，先进先出）

#### 执行栈（execution context stack 先进后出）

主线程的执行栈执行的是同步任务，最先压入栈中的是全局上下文：Global

即遇到执行任务，依次压入执行栈，按照先进后出的规则，依次执行栈中的任务。如果遇到异步任务，则将该任务压入对应的宏任务、微任务队列

#### 任务队列（task queue 先进先出 先检查并执行微任务 -> 检查并执行宏任务）

在执行主线程（同步任务）的过程中，会检查是否存在异步任务（宏任务、微任务 microtask），如存在，则压入对应的任务队列。

当主线程执行完毕时，会向任务队列发送一个消息，查询是否有任务需要执行。如有，按照先进先出的规则执行，先检查是否有微任务队列，有则执行，然后检查是否有宏任务队列，有则执行。如无，继续下一轮的主线程执行。如此循环往复

循环方式：执行栈、任务队列 => rander => 下一次的执行栈、任务队列 => rander => 下一次的执行栈、任务队列

浏览器为了能够使得 JS 内部(macro)task 与 DOM 任务能够有序的执行，会在一个(macro)task 执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染

### 运行机制

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
- 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）

### 三、回收上下文（垃圾回收阶段）

在栈中和任务队列中的任务被执行后，会检查该上下文中是否有变量等被引用，如没有，出栈等待虚拟机回收执行上下文。

全局上下文只有唯一的一个，它最早进栈，浏览器关闭时出栈 a

### 宏任务 macro-task

```js
script(整体代码)
setTimeout
setInterval
I/O
UI交互事件
postMessage
MessageChannel
setImmediate(Node.js 环境)
```

### 微任务 micro-task

```js
Promise.then
Object.observe
MutaionObserver
process.nextTick(Node.js 环境)
```

## 堆栈

堆栈是存放数据的两种不同的结构。主要涉及内存的分配和使用

堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。

### 栈（stack 先进后出，线性）

一般简单类型的数值声明都存在栈中，复杂类型的数据，存在栈中的是引用地址，该地址指向堆中的一个位置。如果执行一个递归，该递归没有设置退出的条件无限的自我调用，就会导致栈溢出 stack overflow 使该进程崩溃

javascript 的基本类: Undefined、Null、Boolean、Number 和 String，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这种按类型分配固定空间的方式，跟 mysql 中的数据类型的空间分配方式如出一辙

### 堆 （heap 键值对）

类似 mongoDB 非关系型数据库的运作方式，无序、按照键值对方式存放

### 相关问题

1、深拷贝、浅拷贝（主要考察数据的存放位置，数据的复制方式、修改方式应该注意哪些）

2、Event Loop（js 的事件循环机制，涉及栈）

## 垃圾回收

js 的执行是内存的不断分配和使用的过程，如果内存不断的被分配，而没有一个清除的机制，就会导致报错：stack overflow （栈溢出）垃圾回收就是用来清除被执行过的代码和内存的占用

## 垃圾回收的机制

### 标记清除

javascript 中最常用的垃圾收集方式是标记清除(mark-and-sweep)，当变量进入环境(例如，在函数中声明一个变量)，就将这个变量标记为'进入环境'。标记的方式有很多种，主要在于清除的策略。

### 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当该值的引用计数为 0 时，则可以清除

### 垃圾占用

1、未使用的全局变量

2、闭包

3、递归
